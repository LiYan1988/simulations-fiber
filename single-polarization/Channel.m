classdef Channel < handle
    %Channel class
    %   Detailed explanation goes here
    % TODO:
    %   1. make Channel copyable, implement copyElement method
    %   2. Channel is used as a data container, so many move all methods to
    %       SinglePolarization?
    %   3. Power assignment for OOK and 16QAM
    
    %% Simulation parameters with set access control
    % These properties can be accessed everywhere, but can only be set by
    % SinglePolarization or Link objects
    properties (GetAccess=public, SetAccess={?SinglePolarization})
        modulation % {'OOK', '16QAM'}
        symbolRate % [Hz]
        centerFrequency % [Hz]
        powerdB % power [dB]
        powerW % power [W]
        
        % Filter parameters
        firFactor % bt of gaussdesign or beta of rcosdesign
        symbolInFir % number of symbols in FIR
        % FIR filter coefficients, a vector generated by gaussdesign or
        % rcosdesign
        fir
        
        % Parameters realted to simulations
        minSamplePerSymbol % minimum sample per symbol, can be higher
        actualSamplePerSymbol % actual sample per symbol in simulation
        minNumberSymbol % minimum number of symbols, can be higher
        actualNumberSymbol % actual number of symbols in simulation
        
        % Transmitted signals
        dataBit % bit sequence
        dataSymbol % symbol sequence
        dataTime % time domain signal
        % dataSpectrum % spectrum domain signal
        % Number of samples to shift dataTime, [0, actualSamplePerSymbol),
        % generated randomly so that, channels are not overlapping in time
        % domain
        shiftNumberSample
    end
    
    properties (Dependent)
        constellationSize % number of points in the constellation diagram
        bitPerSymbol % bits per symbol
    end
    
    %% Methods have public access
    % Construct and dependent get access methods
    methods
        function obj = Channel(varargin)
            %Construct an instance of Channel
            %   Inputs are name-value pairs, default value is for OOK
            
            %% Parse input
            p = inputParser;
            
            validModulation = {'OOK', '16QAM'};
            checkModulation = @(x)any(validatestring(x, validModulation));
            addParameter(p, 'modulation', 'OOK', checkModulation);
            addParameter(p, 'symbolRate', 10e9, @isnumeric);
            addParameter(p, 'centerFrequency', 0e9, @isnumeric);
            addParameter(p, 'powerdB', 0, @isnumeric);
            
            % Filter parameters
            addParameter(p, 'firFactor', 0.7, @isnumeric);
            addParameter(p, 'symbolInFir', 10, @isnumeric);
            
            % Simulation parameters
            addParameter(p, 'minSamplePerSymbol', 4, @isnumeric);
            addParameter(p, 'minNumberSymbol', 1024, @isnumeric);
            
            % Parse the inputs
            parse(p, varargin{:});
            
            %% Set parameters
            obj.modulation = p.Results.modulation;
            obj.symbolRate = p.Results.symbolRate;
            obj.centerFrequency = p.Results.centerFrequency;
            obj.powerdB = p.Results.powerdB;
            obj.powerW = 10.^(obj.powerdB/10)/1e3;
            
            % Filter parameters
            obj.firFactor = p.Results.firFactor;
            obj.symbolInFir = p.Results.symbolInFir;
            
            % Simulation parameters
            obj.minSamplePerSymbol = p.Results.minSamplePerSymbol;
            obj.minNumberSymbol = p.Results.minNumberSymbol;
        end
        
        function constellationSize = get.constellationSize(obj)
            if strcmp(obj.modulation, 'OOK')
                constellationSize = 2;
            elseif strcmp(obj.modulation, '16QAM')
                constellationSize = 16;
            end
        end
        
        function bitPerSymbol = get.bitPerSymbol(obj)
            if strcmp(obj.modulation, 'OOK')
                bitPerSymbol = 1;
            elseif strcmp(obj.modulation, '16QAM')
                bitPerSymbol = 4;
            end
        end
    end
    
    %% Methods can be accessed by SinglePolarization
    methods (Access={?SinglePolarization})
        function obj = generateSignal(obj)
            if strcmp(obj.modulation, 'OOK')
                [obj.dataBit, obj.dataSymbol, obj.dataTime, obj.fir] = ...
                    generateOOK(obj);
            elseif strcmp(obj.modulation, '16QAM')
                [obj.dataBit, obj.dataSymbol, obj.dataTime, obj.fir] = ...
                    generate16QAM(obj);
            end
        end
    end
end

%% Helper Functions for Class Methods
function [dataBit, dataSymbol, dataTime, fir] = generateOOK(obj)
% Generate NRZ OOK without carrier suppress

% Generate bit stream
dataBit = randi([0, 1], obj.actualNumberSymbol, obj.bitPerSymbol);

% Symbol stream
dataSymbol = dataBit;
dataTime = repmat(dataBit, 1, obj.actualSamplePerSymbol).';
dataTime = dataTime(:);
dataTimeLength = length(dataTime);

% Generate Gauss FIR
fir = gaussdesign(obj.firFactor, obj.symbolInFir, obj.actualSamplePerSymbol);
% Pass dataTime through FIR
dataTime = upfirdn(dataTime, fir);
% FIR delay in number of samples
firOverhead = (length(fir)-1)/2;
% Remove head and tail added by FIR and convolution inside upfirdn
s = (firOverhead+1):(firOverhead+dataTimeLength);
dataTime = dataTime(s);
end

function [dataBit, dataSymbol, dataTime, fir] = generate16QAM(obj)
% Generate 16QAM bits
dataBit = randi([0, 1], obj.actualNumberSymbol, obj.bitPerSymbol);

% Symbols
dataSymbol = bi2de(dataBit);
dataSymbol = qammod(dataSymbol, obj.constellationSize);
dataSymbol = dataSymbol/sqrt(mean(abs(dataSymbol).^2)); % 

% Square root raised cosine FIR
fir = rcosdesign(obj.firFactor, obj.symbolInFir, obj.actualSamplePerSymbol, 'sqrt');
% Length of dataTime
dataTimeLength = obj.actualSamplePerSymbol*obj.actualNumberSymbol;
% Pass through FIR with upsample
dataTime = upfirdn(dataSymbol, fir, obj.actualSamplePerSymbol);
% Remove head and tail of dataTime
% This is the head to be removed, because the output length of FIR is 
% ceil(((length(xin)-1)*p+length(h))/q) for yout = upfirdn(xin,h,p,q)
% See Matlab reference of upfirdn and conv
firOverhead = floor((length(fir)-obj.actualSamplePerSymbol)/2);
s = (firOverhead+1):(firOverhead+dataTimeLength);
dataTime = dataTime(s);
end